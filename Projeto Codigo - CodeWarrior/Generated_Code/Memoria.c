/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : Memoria.c
**     Project     : EA076 - Projeto 3
**     Processor   : MKL25Z128VLK4
**     Component   : 24AA_EEPROM
**     Version     : Component 01.040, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2021-01-17, 19:21, # CodeGen: 7
**     Abstract    :
**         Driver for Microchip 24_AA/LC EEPROMs
**     Settings    :
**          Component name                                 : Memoria
**          SDK                                            : MCUC1
**          Device Type                                    : 8
**          Initial I2C Device Address Bits                : 0
**          Block buffer size                              : 16
**          Acknowledge Polling                            : Enabled
**            Page Write Time (ms)                         : 5
**            Wait                                         : WAIT1
**            ACK Polling Time (us)                        : 100
**          Connection                                     : 
**            I2C                                          : GI2C1
**            Write Protection Pin                         : Disabled
**          Timeout                                        : Disabled
**          Shell                                          : Disabled
**     Contents    :
**         ReadByte   - uint8_t Memoria_ReadByte(Memoria_Address addr, uint8_t *data);
**         WriteByte  - uint8_t Memoria_WriteByte(Memoria_Address addr, uint8_t data);
**         ReadBlock  - uint8_t Memoria_ReadBlock(Memoria_Address addr, uint8_t *data, uint16_t...
**         WriteBlock - uint8_t Memoria_WriteBlock(Memoria_Address addr, uint8_t *data, uint16_t...
**         Deinit     - void Memoria_Deinit(void);
**         Init       - void Memoria_Init(void);
**
**     * Copyright (c) 2013-2019, Erich Styger
**      * Web:         https://mcuoneclipse.com
**      * SourceForge: https://sourceforge.net/projects/mcuoneclipse
**      * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx
**      * All rights reserved.
**      *
**      * Redistribution and use in source and binary forms, with or without modification,
**      * are permitted provided that the following conditions are met:
**      *
**      * - Redistributions of source code must retain the above copyright notice, this list
**      *   of conditions and the following disclaimer.
**      *
**      * - Redistributions in binary form must reproduce the above copyright notice, this
**      *   list of conditions and the following disclaimer in the documentation and/or
**      *   other materials provided with the distribution.
**      *
**      * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**      * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**      * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**      * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**      * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**      * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**      * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**      * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**      * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**      * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
** ###################################################################*/
/*!
** @file Memoria.c
** @version 01.00
** @brief
**         Driver for Microchip 24_AA/LC EEPROMs
*/         
/*!
**  @addtogroup Memoria_module Memoria module documentation
**  @{
*/         

/* MODULE Memoria. */

#include "Memoria.h"
#if Memoria_CONFIG_HAS_WP_PIN
  #include "WPpin1.h"
#endif
#include "WAIT1.h"
#include "McuShell.h"
#include "McuUtility.h"
#include "GI2C1.h"
#if Memoria_CONFIG_USE_TIMEOUT
  #include "McuTimeout.h"
#endif

#if Memoria_CONFIG_USE_TIMEOUT
#endif

#define Memoria_I2CAddress (Memoria_CONFIG_DEVICE_I2C_ADDRESS_BITS&Memoria_MAX_I2C_ADDR_MASK) /* address defined by the A2|A1|A0 pins */

/* macros for the control byte: */
#define Memoria_CTRL_NBL       (0x0A<<3) /* control byte high nibble. Typically this is 1010 (shifted by one to the right) */
#if (Memoria_CONFIG_DEVICE_ID==8) || (Memoria_CONFIG_DEVICE_ID==16)
  #define Memoria_CTRL_ADDR      0      /* no additional address bits */
  /* define control byte as 1010|Bx|B1|B0 */
  #define Memoria_BANK_0         (0<<2) /* B0 bit (0) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define Memoria_BANK_1         (1<<2) /* B0 bit (1) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define Memoria_CTRL_BYTE      (Memoria_CTRL_NBL|Memoria_CTRL_ADDR) /* 1010|B0|A1|A0 */
  #define Memoria_DEVICE_ADDR(addr) \
    ( Memoria_CTRL_BYTE|((addr>>8)&0x07) )
  #if 0 /* old style */
    (((addr)&0x400)? \
        (Memoria_CTRL_BYTE|Memoria_BANK_1) \
      : (Memoria_CTRL_BYTE|Memoria_BANK_0) ) /* 7bit address of device used to select device */
  #endif
#elif (Memoria_CONFIG_DEVICE_ID==32) || (Memoria_CONFIG_DEVICE_ID==256) || (Memoria_CONFIG_DEVICE_ID==512)
  #define Memoria_CTRL_ADDR      Memoria_I2CAddress /* address inside control byte */
  /* define control byte as 1010|A2|A1|A0 */
  #define Memoria_CTRL_BYTE         (Memoria_CTRL_NBL|Memoria_CTRL_ADDR) /* 1010|A2|A1|A0 */
  #define Memoria_DEVICE_ADDR(addr) Memoria_CTRL_BYTE /* 7bit address of device used to select device */
#elif Memoria_CONFIG_DEVICE_ID==1025
  #define Memoria_CTRL_ADDR      Memoria_I2CAddress /* address inside control byte */
  /* define control byte as 1010|Bx|A1|A0 */
  #define Memoria_BANK_0         (0<<2) /* B0 bit (0) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define Memoria_BANK_1         (1<<2) /* B0 bit (1) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define Memoria_CTRL_BYTE      (Memoria_CTRL_NBL|Memoria_CTRL_ADDR) /* 1010|B0|A1|A0 */
  #define Memoria_DEVICE_ADDR(addr) \
    (((addr)&0x10000)? \
        (Memoria_CTRL_BYTE|Memoria_BANK_1) \
      : (Memoria_CTRL_BYTE|Memoria_BANK_0) ) /* 7bit address of device used to select device */
#endif

/*
** ===================================================================
**     Method      :  Memoria_WriteByte (component 24AA_EEPROM)
**     Description :
**         Writes a single byte to specified address
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - The address inside the EEPROM
**         data            - The data value to write
**     Returns     :
**         ---             - Error code, possible values
**                           ERR_OK - OK
**                           otherwise it can return an error code of
**                           the underlying communication protocol.
** ===================================================================
*/
uint8_t Memoria_WriteByte(Memoria_Address addr, uint8_t data)
{
  uint8_t res, block[3];
#if Memoria_CONFIG_USE_TIMEOUT
#endif

  res = GI2C1_SelectSlave(Memoria_DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  #if (Memoria_CONFIG_DEVICE_ID==8) || (Memoria_CONFIG_DEVICE_ID==16)
    block[0] = (uint8_t)(addr&0xff);    /* low byte of address */
    block[1] = data; /* switch to read mode */
    res = GI2C1_WriteBlock(block, 2, GI2C1_SEND_STOP); /* send address and data */
  #else
    block[0] = (uint8_t)(addr>>8);      /* high byte of address */
    block[1] = (uint8_t)(addr&0xff);    /* low byte of address */
    block[2] = data; /* switch to read mode */
    res = GI2C1_WriteBlock(block, sizeof(block), GI2C1_SEND_STOP); /* send address and data */
  #endif
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
#if Memoria_DO_ACKNOWLEDGE_POLLING
  /* do acknowledge polling */
  block[0] = 0xff; /* dummy value */
#if Memoria_CONFIG_USE_TIMEOUT
#endif
  do {
#if Memoria_CONFIG_USE_TIMEOUT
#endif
    WAIT1_WaitOSms(Memoria_CONFIG_PAGE_WRITE_TIME_MS);
    res = GI2C1_ProbeACK(block, 1, GI2C1_SEND_STOP, Memoria_CONFIG_ACK_POLLING_TIME_US); /* send address and data */
  } while(res!=ERR_OK); /* wait until we get an ACK */
#if Memoria_CONFIG_USE_TIMEOUT
#endif
#endif /* Memoria_CONFIG_DO_ACKNOWLEDGE_POLLING */
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  return GI2C1_UnselectSlave();
}

/*
** ===================================================================
**     Method      :  Memoria_ReadByte (component 24AA_EEPROM)
**     Description :
**         Reads a single byte from the given memory address
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - The address where to read from memory.
**       * data            - Pointer to a location where to store the
**                           data
**     Returns     :
**         ---             - Error code, possible values
**                           ERR_OK - OK
**                           otherwise it can return an error code of
**                           the underlying communication protocol.
** ===================================================================
*/
uint8_t Memoria_ReadByte(Memoria_Address addr, uint8_t *data)
{
  uint8_t res;
  #if (Memoria_CONFIG_DEVICE_ID==8) || (Memoria_CONFIG_DEVICE_ID==16)
    uint8_t addr8;
    addr8 = (uint8_t)(addr&0xff); /* low address byte */
  #else
    uint8_t addr16[2];                  /* big endian address on I2C bus needs to be 16bit */

    addr16[0] = (uint8_t)(addr>>8); /* 16 bit address must be in big endian format */
    addr16[1] = (uint8_t)(addr&0xff);
  #endif

  res = GI2C1_SelectSlave(Memoria_DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  #if (Memoria_CONFIG_DEVICE_ID==8) || (Memoria_CONFIG_DEVICE_ID==16)
    res = GI2C1_WriteBlock(&addr8, 1, GI2C1_DO_NOT_SEND_STOP); /* send 8bit address */
  #else /* use 16bit address */
    res = GI2C1_WriteBlock(addr16, 2, GI2C1_DO_NOT_SEND_STOP); /* send 16bit address */
  #endif
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  res = GI2C1_ReadBlock(data, 1, GI2C1_SEND_STOP); /* read data byte from bus */
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  return GI2C1_UnselectSlave();
}

/*
** ===================================================================
**     Method      :  Memoria_ReadBlock (component 24AA_EEPROM)
**     Description :
**         Read a block of memory.
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - Address where to read the memory
**       * data            - Pointer to a buffer where to store the
**                           data
**         dataSize        - Size of buffer the data pointer
**                           is pointing to
**     Returns     :
**         ---             - Error code, possible values
**                           ERR_OK - OK
**                           otherwise it can return an error code of
**                           the underlying communication protocol.
** ===================================================================
*/
uint8_t Memoria_ReadBlock(Memoria_Address addr, uint8_t *data, uint16_t dataSize)
{
  uint8_t res;
  #if (Memoria_CONFIG_DEVICE_ID==8) || (Memoria_CONFIG_DEVICE_ID==16)
    uint8_t addr8;
    addr8 = (uint8_t)(addr&0xff);
  #else
    uint8_t addr16[2];                  /* big endian address on I2C bus needs to be 16bit */
    addr16[0] = (uint8_t)(addr>>8); /* 16 bit address must be in big endian format */
    addr16[1] = (uint8_t)(addr&0xff);
  #endif

  res = GI2C1_SelectSlave(Memoria_DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  #if (Memoria_CONFIG_DEVICE_ID==8) || (Memoria_CONFIG_DEVICE_ID==16)
    res = GI2C1_WriteBlock(&addr8, 1, GI2C1_DO_NOT_SEND_STOP); /* send 8bit address */
  #else
    res = GI2C1_WriteBlock(addr16, 2, GI2C1_DO_NOT_SEND_STOP); /* send 16bit address */
  #endif
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  res = GI2C1_ReadBlock(data, dataSize, GI2C1_SEND_STOP);
  if (res != ERR_OK) {
    (void)GI2C1_UnselectSlave();
    return res;
  }
  return GI2C1_UnselectSlave();
}

/*
** ===================================================================
**     Method      :  Memoria_WriteBlockPage (component 24AA_EEPROM)
**
**     Description :
**         Writes a block with pages of data to the EEPROM
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#ifdef __HIWARE__
#pragma MESSAGE DISABLE C1855 /* recursive function call */
#endif
uint8_t Memoria_WriteBlockPage(Memoria_Address addr, uint8_t *data, uint16_t dataSize)
{
#if Memoria_CONFIG_USE_TIMEOUT
#endif
  uint8_t res, i, *p, block[Memoria_CONFIG_BLOCK_BUF_SIZE+2]; /* additional 2 bytes for the address */
  uint16_t eepromPage = (uint16_t)(addr/Memoria_PAGE_SIZE);
  uint8_t offset = (uint8_t)(addr%Memoria_PAGE_SIZE);

  if (dataSize==0 || dataSize>Memoria_CONFIG_BLOCK_BUF_SIZE) {
    return ERR_OVERFLOW;                /* you may increase the buffer size in the properties? */
  }
  if (dataSize>Memoria_PAGE_SIZE) {
    uint16_t size;

    size = (uint16_t)(Memoria_PAGE_SIZE-offset);
    if (size!=0) {
      res = Memoria_WriteBlock(addr, data, size); /* first page write */
      if (res != ERR_OK) {
        return res;
      }
      data += size; /* increment data pointer */
      addr += size; /* increment address */
      dataSize -= size; /* reduce size */
    }
    /* write multiple block of PAGE_SIZE */
    while (dataSize>Memoria_PAGE_SIZE) {
      res = Memoria_WriteBlock(addr, data, Memoria_PAGE_SIZE);
      if (res != ERR_OK) {
        return res;
      }
      data += Memoria_PAGE_SIZE; /* increment data pointer */
      addr += Memoria_PAGE_SIZE; /* increment address */
      dataSize -= Memoria_PAGE_SIZE; /* reduce size */
    }
    /* write remainder (if any) */
    if (dataSize>0) {
      return Memoria_WriteBlock(addr, data, dataSize);
    }
    return ERR_OK;
  }
  if (offset+dataSize <= Memoria_PAGE_SIZE) { /* no page boundary crossing */
    res = GI2C1_SelectSlave(Memoria_DEVICE_ADDR(addr));
    if (res != ERR_OK) {
      (void)GI2C1_UnselectSlave();
      return res;
    }
    #if (Memoria_CONFIG_DEVICE_ID==8) || (Memoria_CONFIG_DEVICE_ID==16)
      /* 8 bit address byte, high byte of address have been place in SelectSlave(addr) */
      block[0] = (uint8_t)(addr&0xff);  /* low byte of address */
      p = &block[1]; i = (uint8_t)dataSize;
    #else /* 16 bit address byte */
      block[0] = (uint8_t)(addr>>8);    /* high byte of address */
      block[1] = (uint8_t)(addr&0xff);  /* low byte of address */
      p = &block[2]; i = (uint8_t)dataSize;
    #endif

    /* copy block */
    while(i>0) {
      *p++ = *data++;
      i--;
    }
    res = GI2C1_WriteBlock(block,
        dataSize+((Memoria_CONFIG_DEVICE_ID==8)||(Memoria_CONFIG_DEVICE_ID==16)? 1:2), GI2C1_SEND_STOP); /* send address and data */
    if (res != ERR_OK) {
      (void)GI2C1_UnselectSlave();
      return res;
    }
#if Memoria_DO_ACKNOWLEDGE_POLLING
    /* do acknowledge polling */
#if Memoria_CONFIG_USE_TIMEOUT
#endif
    block[0] = 0xff; /* dummy value */
    do {
      WAIT1_WaitOSms(Memoria_CONFIG_PAGE_WRITE_TIME_MS);
      res = GI2C1_ProbeACK(block, 1, GI2C1_SEND_STOP, Memoria_CONFIG_ACK_POLLING_TIME_US); /* send address and data */
#if Memoria_CONFIG_USE_TIMEOUT
#endif
    } while(res!=ERR_OK); /* wait until we get an ACK */
#if Memoria_CONFIG_USE_TIMEOUT
#endif
    if (res != ERR_OK) {
      (void)GI2C1_UnselectSlave();
      return res;
    }
#endif /* Memoria_CONFIg_DO_ACKNOWLEDGE_POLLING */
    return GI2C1_UnselectSlave();
  } else { /* crossing page boundaries: make two page writes */
    res = Memoria_WriteBlock(addr, data, (uint16_t)(Memoria_PAGE_SIZE-offset)); /* first page write */
    if (res != ERR_OK) {
      return res;
    }
    res = Memoria_WriteBlock((Memoria_Address)((eepromPage+1)*Memoria_PAGE_SIZE),
       data+(Memoria_PAGE_SIZE-offset),
       (uint16_t)(dataSize-(Memoria_PAGE_SIZE-offset))); /* first page write */
    if (res != ERR_OK) {
      return res;
    }
  }
  return res;
}
#ifdef __HIWARE__
  #pragma MESSAGE DEFAULT C1855 /* recursive function call */
#endif

/*
** ===================================================================
**     Method      :  Memoria_WriteBlock (component 24AA_EEPROM)
**     Description :
**         Writes a block of data to the EEPROM
**     Parameters  :
**         NAME            - DESCRIPTION
**         addr            - Address of memory
**       * data            - Pointer to the data
**         dataSize        - Size of data
**     Returns     :
**         ---             - Error code, possible values
**                           ERR_OK - OK
**                           ERR_OVERFLOW - data block passed has either
**                           size of zero or exceeds internal buffer
**                           size
**                           otherwise it can return an error code of
**                           the underlying communication protocol.
** ===================================================================
*/
uint8_t Memoria_WriteBlock(Memoria_Address addr, uint8_t *data, uint16_t dataSize)
{
  int32_t size;

  if (dataSize<=Memoria_CONFIG_BLOCK_BUF_SIZE) { /* fits into internal buffer */
    return Memoria_WriteBlockPage(addr, data, dataSize);
  }
  size = dataSize;
  while(size>=Memoria_CONFIG_BLOCK_BUF_SIZE) { /* write in chunks Memoria_CONFIG_BLOCK_BUF_SIZE */
    if (Memoria_WriteBlock(addr, data, Memoria_CONFIG_BLOCK_BUF_SIZE)!=ERR_OK) {
      return ERR_FAILED;
    }
    addr += Memoria_CONFIG_BLOCK_BUF_SIZE;
    data += Memoria_CONFIG_BLOCK_BUF_SIZE;
    size -= Memoria_CONFIG_BLOCK_BUF_SIZE;
  }
  if (size>0) { /* write remainder which is < EE241_BLOCK_BUF_SIZE  */
    if (Memoria_WriteBlockPage(addr, data, size)!=ERR_OK) {
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  Memoria_Deinit (component 24AA_EEPROM)
**     Description :
**         Driver de-initialization
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void Memoria_Deinit(void)
{
  /* nothing needed */
}

/*
** ===================================================================
**     Method      :  Memoria_Init (component 24AA_EEPROM)
**     Description :
**         Driver initialization
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void Memoria_Init(void)
{
  /* nothing needed */
}

/* END Memoria. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
